# list
**여러 개의 값을 순서대로 저장**하는, **변경 가능한(mutable)** 시퀀스 자료형
```python
my_list = [1, 'a', 3, 'b', 5]
```
### 리스트 표현
- 대괄호 [] 안에 값들을 쉼표로 구분하여 표현
- 숫자, 문자열, 심지어 다른 리스트까지 모든 종류의 데이터를 담을 수 있음
- 값들을 추가, 수정, 삭제하는 등 자유롭게 변경 가능
## 시퀀스로서의 리스트
리스트는 시퀀스이므로 문자열처럼 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능 모두 사용 가능
```python
my_list = [1, 'a', 3, 'b', 5]

# 인덱싱
my_list[3] # 'b'

# 슬라이싱
my_list[1:4] # ['a', '3', 'b']

# 길이 확인
len(my_list) # 5
```
## 중첩 리스트
```python
my_list = [1, 'two', 3, ['eins', 'zwei', 'drei']]
```
- 리스트 내에 다른 리스트를 중첩해서 넣을 수 있음
- 만약에 리스트 안의 리스트의 내용을 출력하고 싶다면
```python
# ['eins', 'zwei', 'drei']
print(my_list[3])

# 'zwei'
print(my_list[3][1])
```
- 위의 방식대로 리스트가 있는 순서를 먼저 입력하고 그 리스트 내의 원하는 내용이 있는 순서를 입력
## 리스트의 가변성
- 한 번 생성된 리스트는 그 내용을 자유롭게 수정, 추가, 삭제가 가능
```python
my_list = [1, 'a', 3, 'b', 5, 'c']

my_list[1] = 2
print(my_list) # [1, 2, 3, 'b', 5, 'c']

my_list[2:4] = ['hi', 'hello']
print(my_list) #[1, 2, 'hi', 'hello', 5, 'c']

my_list[2:4] = ['안녕', '안녕하세요', '반가워요']
print(my_list) # [1, 'a', '안녕', '안녕하세요', '반가워요', 5, 'c']
```

# tuple
여러 개의 값을 순서대로 저장하는, 변경 불가능한 시퀀스 자료형
### 튜플 표현
- 소괄호()안에 값들이 쉼표(,)로 구분
- 모든 종류의 데이터를 담을 수 있음
- 리스트와 비슷하지만, 한번 입력하면 변경할 수 없다는 점에서 차이점 발생
```python
my_tuple_1 = ()
my_tuple_2 = (1,) # 값이 1개인 경우 뒤에 쉼표를 꼭 붙여줘야 함
my_tuple_3 = (1, 'a', 3, 'b', 5)
my_tuple_4 = 1, 'hello', 3.14, True
```
## 시퀀스로서의 튜플
튜플도 시퀀스형 자료형이기 때문에 인덱싱, 슬라이싱, 길이 확인, 반복등이 가능
```python
my_tuple = (1, 'a', 3, 'b', 5)

#인덱싱
my_tuple[2] # 3

#슬라이싱
my_tuple[1:] # ('a', 3, 'b', 5)
my_tuple[:3] # (1, 'a', 3)
my_tuple[1:4] # ('a', 3, 'b')
my_tuple[::2] # (1, 3, 5)

# 길이 확인
len(my_tuple) # 5
```

## 튜플의 불변성
한 번 생성된 튜플은 절대 수정, 추가, 삭제가 불가능!
```python
my_tuple = (1, 'a', 3, 'b', 5)

# TypeError: 'tuple' object does not support item assignment
my_tuple[1] = 'z'
```
### 튜플이 활용되는 곳은 어디일까?
**데이터를 안전하게 전달해야 하는 내부 동작에서 주로 활용!**

# range
연속된 정수 시퀀스에 사용되는, 변경 불가능한 시퀀스 자료형
## range 기본 구문
`range(start, stop, step)`  
`start`: 정수 시퀀스가 시작하는 지점 (이상)  
`stop`: 정수 시퀀스가 끝나는데 포함이 안되는 지점 (미만)  
`step`: 정수 시퀀스가 건너뛰는 숫자의 크기  

`range`는 `list`에 넣으면 확인 가능!
## range의 규칙
1. 값의 범위 규칙
   - `stop`에 들어가는 값은 절대 값에 포함되지 않음
2. 증가/감소 규칙
   - 증가할 때: `start`와 `stop`의 방향이 순방향이여야 함
   - 감소할 때: `start`와 `stop`의 방향이 역방향이여야 하고, `step`에는 음수가 들어가야 함

### range 활용 예시
`for`문과 같이 활용이 많이 됨
```python
arr = []
for i in range(10):
    arr.append(i)
print(arr) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```
# dict
**key-value** 쌍으로 이루어진 순서와 중복이 없는 변경 하는 자료형
```python
my_f1 = {'max':'red_bull', 'oscar':'mclaren', 'luis':'ferrai'}
```
### 딕셔너리 표현
- 중괄호{}안에 값들이 쉼표(,)로 구분
- 값 한 개는 key(키)와 value(값)으로 구성되어 있음  
    `{key : value}`
    - key(키): 값을 식별하기 위한 고유한 '이름표'
    - value(값): 키에 해당하는 실제 데이터
>[!WARNING]  
>**딕셔너리 순서?**
>- 딕셔너리는 순서가 없는 자료형이지만 파이썬 3.7 이상에서는 입력한 순서대로 출력 시 그대로 유지
>- 하지만 여전히 딕셔너리의 핵심은 **순서가 없는 자료형**이라는 점과 **Key를 통한 접근**이라는 점!

## 딕셔너리 규칙
### Key 규칙
- 고유성이 있어야 함 (**Key는 중복 불가!**)
- 변경 불가능한 자료형만 이용 가능
    - 사용 가능: `str`, `int`, `float`, `tupple`
    - 사용 불가능: `list`, `dict`
### Value 규칙
- 어떤 자료형이든 자유롭게 사용 가능
## 딕셔너리 값 접근
- Key를 이용해 해당 Value를 꺼낼 수 있음
- Key에 접근 시 대괄호[] 사용
```python
my_f1 = {'max':'red_bull', 'oscar':'mclaren', 'lewis':'mercedes'}
p
print(my_f1['max']) # 'red_bull'
print(my_f1['lando']) # KeyError: 'lando'
```
### 딕셔너리 값 추가 및 변경
```python
my_f1 = {'max':'red_bull', 'oscar':'mclaren', 'lewis':'mercedes'}

# 값 추가
my_f1['george'] = 'mercedes'
print(my_f1) # {'max': 'red_bull', 'oscar': 'mclaren', 'lewis': 'mercedes', 'george': 'mercedes'}

# 값 변경
my_f1['lewis'] = 'ferrai'
print(my_f1) # {'max': 'red_bull', 'oscar': 'mclaren', 'lewis': 'ferrai', 'george': 'mercedes'}
```
>[!TIP]  
>만약에 `dict`과 `list`가 혼합되어 있는 경우
>```python
> my_f1 = {
>    'max': 'red_bull',
>    'oscar': 'mclaren',
>    'lewis': 'mercedes',
>    'teams': ['red_bull', 'mclaren', 'mercedes'],
>    'positions': [{'driver': 'max', 'position': 1}, {'driver': 'oscar', 'position': 2}]
>}
>```
>여기서 'max'의 'position'을 출력하고 싶다면  
>`print(my_f1['positions'][0]['position']) # 1`

# set
순서와 중복이 없는 변경 가능한 자료형
### set 표현
소괄호{}안에 있는 값들이 쉼표(,)로 구분
### 특징
1. 중복을 허용하지 않음
2. 순서가 없음
```python
my_set_1 = set() # 소괄호만 입력하는 것은 dict이 우선이기 때문에 빈 set을 구성하는 경우 set()으로 설정
my_set_2 = {1, 2, 3, 4}
my_set_3 = {1, 1, 1, 1} # print(my_set_3) 하면 결과는 {1}로 출력
```
## 세트의 집합 연산
세트는 집합연산을 그대로 사용이 가능함
`my_set_1 = {1, 2, 3}`, `my_set_2 = {3, 5, 6}`
1. 합집합
`print(my_set_1 | my_set_2)` `# {1, 2, 3, 5, 6}`   
2. 교집합
`print(my_set_1 & my_set_2)` `# {3}` 
3. 차집합
`print(my_set_1 - my_set_2)` `# {1, 2}` 

# Other Types
## None
파이썬에서 **값이 없음**을 표현하는 특별한 데이터 타입 (아직 값이 정해지지 않음을 나타내는 것)
## Boolean
True/False 두가지 값만 가지는 데이터 타입

# Collection
여러 개의 값을 하나로 묶어 관리하는 자료형을 통칭하는 말 (여러 물건을 담는 보관함 같은 것)
|컬렉션명|변경가능여부|순서존재여부||
|--------|----------|-----------|------|
|`str`|X|O|시퀀스형|
|`list`|O|O|시퀀스형|
|`tuple`|X|O|시퀀스형|
|`dict`|O|X|비시퀀스형|
|`set`|O|X|비시퀀스형|
## 불변과 가변
컬렉션 타입은 생성 후 값을 변환할 수 있냐 없냐로도 나눌 수 있음
- 불변형: `str`, `tuple`
- 가변형: `list`, `dict`, `set`
  
# 형변환
한 데이터 타입을 다른 데이터 타입으로 변경하는 것
## 암시적 형변환
파이썬이 연산 중에 자동으로 데이터 타입을 변경하는 것
### 예시
```python
print(3 + 5.0) # 8.0
print(True + 4) # 5
print(True + False) #2
```
## 명시적 형변환
사용자가 원하는 데이터 타입으로 변경하는 것  
대표적으로 `str`→`int`, `int` → `str`로 변경하는 것을 많이 사용
|함수|설명|예시|결과값|
|----|----|----|----|
|`str()`|문자로 변환|`str(2)`|'2'|
|`int()`|정수로 변환|`int('2')`|2|
|`float()`|소수로 변환|`float(2)`|2.0|
|`tuple()`|튜플로 변환|`tuple([1, 2, 3])`|(1, 2, 3)|
|`set()`|세트로 변환|`set([1, 1, 1])`|{1}|
|`list()`|리스트로 변환|`list((1, 2, 3))`|[1, 2, 3]|


# 연산자
## 산술 연산자
|연산자|설명|
|----|----|
|+|덧셈|
|-|뺄셈|
|*|곱셈|
|/|나눗셈|
|//|몫 나눗셈|
|%|나머지|
|**|거듭제곱|
|-|음수 부호|
## 복합 연산자
|연산자|예시|의미|
|----|----|----|
|+=|`a += b`|`a = a + b`|
|-=|`a -= b`|`a = a - b`|
|*=|`a *= b`|`a = a * b`|
|/=|`a /= b`|`a = a / b`|
|//=|`a //= b`|`a = a // b`|
|%=|`a %= b`|`a = a % b`|
|**=|`a **= b`|`a = a ** b`|
## 비교 연산자
|연산자|설명|
|----|----|
|>|초과|
|>=|이상|
|<|미만|
|<=|이하|
|==|같다|
|!=|같지 않다|
|is|같다|
|is not|같지 않다|

>[!WARNING]  
>**`is`와 `==`의 차이**  
>`is`는 데이터의 주소가 같은 곳에 있는지를 판단하고 `==`의 데이터의 값이 같은지를 판단한다.
>```python
> a = [1, 2]
> b = [1, 2]
> print(a is b) # False
> print(a == b) # True
>```
> 그래서 `is` 연산자는 **단 하나의 객체에서만 생성되어 재사용**되는 싱글턴 객체(`None`, `True`, `False`)를 비교할 때 많이 사용
## 논리 연산자
|기호|연산자|내용|
|----|----|----|
|`and`|논리곱|두 연산자가 모두 `True`일 때 `True`로 평가|
|`or`|논리합|두 연산자 중 하나라도 `True`일 때 `True`로 평가|
|`not`|논리부정|단일 피연산자를 부정|
## 단축 평가
- 논리 연산에서 두번째 피연산자를 평가하지 않고 결과를 결정하는 동작
- 꼭 필요한 계산만 하고, 결과가 이미 정해저 있는 경우 굳이 뒤에 있는 코드까지 확인하지 않음
## 멤버십 연산자
특정 값이 시퀀스나 다른 컬렉션 안에 포함되어 있는지 확인하는 연산자
|기호|내용|
|----|----|
|`in`|왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 포함되는지를 확인|
|`not in`|왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 포함 안되는지 확인|
## 시퀀스형 연산자
- 시퀀스 자료형(문자열, 리스트, 튜플)에 특별한 의미로 사용되는 연산자
- `+`는 시퀀스를 연결하는 기능을, `*`는 시퀀스를 반복하는 기능을 함
## 연산자 우선순위
|우선순위|연산자|내용|
|-------|-------|-----|
|높음|()|소괄호 grouping|
||[]|인덱싱, 슬라이싱|
||**|거듭제곱|
||+, -|단항 연산자 양수/음수|
||*, /, //, % |산술 연산자|
||+, -|산술연산자|
||<, <=, >, >=, ==, !=|비교연산자|
||`is`, `is not`|객체비교|
||`in`, `not in`|멤버십 연산자|
||`not`|논리부정|
||`and`|논리곱|
|낮음|`or`|논리합|
