# 표현식과 값
## 표현식 (Expression)
하나의 '값으로 평가될 수 있는 모든 코드

## 값 (value)
표현식이 평가된 결과
- 더 이상 계싼되거나 평가될 수 없는, 프로그램의 가장 기본적인 데이터 조각   
>3 + 5 --> 표현식   
>8 --> 값
### 표현식, 평가 그리고 값
|개념|설명|
|---|---|
|표현식|3+5 같은 값으로 평가 될 수 있는 코드|
|평가|표현식을 계산하여 값을 만들어 냄|
|값|표현식이 평가된 결과|
# 변수와 메모리
## 변수(variable)
값을 나중에 다시 사용하기 위해, 그 값에 붙여주는 고유한 이름
## 변수 할당 (variable assignment)
표현식이 만들어 낸 값에 이름을 붙이는 과정 (연결)  
`degrees = 36.5`  
|요소|설명|
|---|---|
|degrees|변수 이름|
|=|할당 연산자 (오른쪽 표현식의 평가 결과 값을 왼쪽 변수에 저장)|
|36.5|표현식|

## 할당문 동작 순서
`Variable = expression`
1. 오른쪽 표현식 평가: 할당 연산자의 오른쪽에 있는 표현식 전체를 계산하여 하나의 결과값(객체)를 만듦
2. 왼쪽 변수명 확인
   - 이름이 처음 사용된 경우: 새로운 '이름표' 준비
   - 이미 존재하는 이름: 기존 '이름표'를 그대로 사용
3. 변수명과 결과값 연결 (참조)
   - 마지막으로 왼쪽의 변수명이 오른쪽에서 만들어진 결과값을 가리키도록 연결
   - 만약 변수명이 이전에 다른 객체를 가리키고 있었다면, 그 연결은 끊어지고 새로운 객체와의 연결만 남음 (재할당)
## 재할당
이미 값이 할당된 변수에 새로운 값을 다시 할당하는 것
```python
degrees = 36.5
degress = 'Hello'

#Hello
print(degrees)
```

# 정리
|용어|핵심 정의|비유(주소록)|
|---|---|---|
|객체(Object)|데이터(값, 타입, 행동)의 실체|'김철수'라는 실제 사람|
|메모리 주소|객체가 저장된 고유한 위치|'김철수'의 실제 집 주소|
|변수(Variable)|객체를 가리키는 이름표|주소록에 저장된 '내 친구 철수'라는 이름|

# Data Types
## 타입(Type)
변수나 값이 가질 수 있는 데이터 종류
- 어떤 종류의 데이터인지, 어떻게 해석되고 처리되어야 하는지를 정의
### 타입의 구성요소 2가지
타입은 '값'과 '값에 적용할 수 있는 연산' 2가지 요소로 구분
> 1 + 2에서 1과 2는 값(피연산자) / +는 연산

## 데이터 타입(Data Types)
값의 종류와 그 값으로 할 수 있는 '동작(연산)'을 결정하는 속성  
→ 각 타입에 따라 가능한 기능과 연산이 다르기 때문에 데이터 타입이 필요함
### 데이터 타입 분류 5가지
|분류|종류|
|-------------|-----------------------------------------------|
|Numeric Types|`int`(정수), `float` (실수), `complex` (복소수)|
|Text Sequence Type|`str` (문자열)|
|Sequence Type|`list`, `tuple`, `range`|
|Non Sequence Type|`set`, `dict`|
|기타|`Boolean`, `None`, `Functions`|
## 숫자형 데이터
### 정수형 (int)
소수점이 없는 숫자를 표현  
`student_count = 30`
### 실수형 (float)
소수점이 있는 더 정밀한 숫자를 표현  
`pi = 3.14`
>[!NOTE]
>**지수 표현법**  
>아주 크거나 아주 작은 실수를 간결하게 표현하기 위해 사용하는 방식
>'e' 또는 'E' 사용
>```python
># 1,230,000,000 (1.23 * 10^9)
>big_number = 1.23e9
>
># 0.00314 (3.14 * 10^-3)
>small_number = 3.14e-3
>```

## 숫자형의 '행동': 산술 연산
### 산술 연산자
|연산자|설명|
|----|----|
|+|덧셈|
|-|뺄셈|
|*|곱셈|
|/|나눗셈|
|//|몫 나눗셈|
|%|나머지|
|**|거듭제곱|
|-|음수 부호|
### 연산자 우선순위
|우선순위|연산자|
|-------|-------|
|높음|** (거듭제곱)|
||- (음수 부호)|
||* (곱셈), / (나눗셈), // (몫 나눗셈), % (나머지)|
|낮음|+ (덧셈), - (뺄셈)|

```python
# 계산 결과 비교
print(-2 ** 4)   # -16
print(-(2 ** 4)) # -16
print((-2) ** 4) # 16
```


# Sequence Types
## 시퀀스 타입의 5가지 공통 특징
### 순서 (Order)
값들이 순서대로 저장 (정렬 X)
### 인덱싱 (Indexing)
각 값에 고유 번호(인덱스)를 가지고 있으며, 인덱스를 사용하여 특정 위치의 값을 선택하거나 수정할 수있음
### 슬라이싱 (Slicing)
인덱스 범위를 조절해 전체 데이터 중 원하는 부분만 값을 잘라내서 사용 가능
### 길이 (Length)
`len()`함수를 사용하여 저장된 값의 개수(길이)를 구할 수 있음
### 반복 (Iteration)
반복문을 사용하여 각 값을 하나씩 순서대로 꺼낼 수 있음  

### 시퀀스 타입 특징 예시
`my_data = 'Hello'`  
|특징|사용예시|결과|
|-----|-----|-----|
|인덱싱|`my_data[0]`|`'H'`|
|슬라이싱|`my_data[1:4]`|`'ell'`|
|길이|`len(my_data)`|`5`|
|반복|`for char in my_data`|`H, e, l, l, o`를 차례대로 출력|

# 문자열

# 문자열에 값 삽입하기: f-string
문자열 내에 변수나 표현식의 결과를 손쉽게 삽입하는 강력한 방법
- 문자 시작 전에 f를 붙이고 '{표현식}' 형태로 적기
```python
name = 'max_verstappen'
age = 27
team = 'red_bull_racing'

# His name is max_verstappen, he is 27 years old, and his team is red_bull_racing
print(f'His name is {name}, he is {age} years old, and his team is {team}')
```

# 시퀀스로서의 문자열
## 인덱스 (Index)
시퀀스에서 각 값의 위치를 구별하기 위해 붙이는 고유 번호
>[!NOTE]
>**왜 인덱스는 0번부터 시작할까?**  
>순서라고 생각하지 말고 거리라고 생각하면 편하다. 즉, **시작지점에서 얼마나 멀리 떨어져 있나**로 생각해야 한다.  

||h|e|l|l|o|
|-|-|-|-|-|-|
|순방향|0|1|2|3|4|
|역방향|-5|-4|-3|-2|-1|

## 슬라이싱(Slicing)
```python
my_sequence[start:stop:step]
```
`start`: 슬라이싱 시작 지점(이상)  
`stop`: 슬라이싱 끝나는 지점(미만)  
`step`: 숫자를 몇 개씩 건너뛰면서 반복할건지  

### 슬라이싱 예시
```python
my_str = 'hello'
```
```python
my_str[1:] # 'ello'
my_str[:3] # 'hel'
my_str[::2] # 'hlo'
my_str[::-1] # 'olleh'
my_str[1:3] # 'el'
my_str[1:4:2] # 'el'
my_str[5:2:-1] # 'ol'
```

# 문자열의 불변성
```python
my_str = 'hello'
# TypeError: 'str' object does not support item assignment
my_str[2] = 'r'

my_str = my_str[:2] + 'r' + my_str[3:]
# herlo
print(my_str)
```

>[!WARNING]
>한 번 생성된 문자열 객체는 더 이상 수정할 수 없다.  
>현재 위에 보이는 예시는 수정된 것처럼 보이지만 슬라이싱을 이용해 새로운 값으로 재할당 한 것이지, 수정된 것이 아니다!
